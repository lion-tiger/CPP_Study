

chap01      P2
模拟鸭子应用
Joe SimDuck
标注的OO技术 系统内部设计

鸭子超类 各种鸭子继承此超类

父类 共性
子类 个性

抽象display
头脑风暴会议

经理 主管 程序员

叫 游泳  飞

父类 有飞的方法

不是所有的子类 能飞

父类中加上方法 不是所有的子类都有这个方法

对代码所做的局部修改，影响层面不只是局部

设计
当涉及到维护时， 为了复用目的使用的继承 结局并不完美

子类覆盖父类的方法

========================
利用接口    
interface

更新产品

检查可能需要覆盖fly 和 quark方法

fly和quark从超类中提取出来，  放到接口中


需要一个更清晰的方法  让某些鸭子 可飞 可叫


接口 的代码不能复用！

采用良好的OO软件设计原则！！

一种建立软件的方法

工作 构建 编程语言

继承不能很好的解决问题


java接口不具有实现代码，所以继承接口无法达到代码的复用 == 无论何时需要修改fly行为时，必须往下追踪每一个定义此行为的类中修改它，
一不小心，会造成新的错误。


有一个设计原则  需要变化的代码独立出来，独立封装出来，  不要和不需要变化的代码混在一起

系统中的某部分改变不会影响其他部分

结果就是 代码变化引起的不经意后果变少，系统变的更有弹性


分开变化和不会变化的部分

duck类的  fly quack 会随着鸭子的不同而改变


设计鸭子的行为
如何设计行为的类呢？

一切有弹性


java接口？？？

指定行为到鸭子的实例？  让鸭子的行为动态改变
鸭子类中包含设定行为的方法 运行时动态改变绿头鸭的飞行行为

设计原则： 针对接口编程 而不是针对实现编程

接口代表行为 行为的每个实现 实现其中的一个接口

由行为类 而不是 duck类 实现行为接口

鸭子的子类 使用接口所表示的行为，  具体行为编写在了实现行为的类中



flybehavior设计成接口  抽象类

针对接口编程


抽象超类型可以是接口 也可以是抽象类

对应的类负责实现具体的行为

行为与鸭子类无关

实现鸭子的行为 --》 整合鸭子的行为

不在乎接口的对象具体是什么，直观新对象知道如何quack() 就够了。

行为设定成具体的类   运行时在构造函数里指定具体的类

=================================================

动态设定行为
P20  未代码实现！！！！

================================================

封装行为的大局观
鸭子模拟器
整体格局

整个重新设计后的类结构

一组行为 --》 一族算法

注意类关系

有一个  has a   组合
是一个  is  a   继承

组合 继承

提高可维护性 可扩展性上的复用程度

策略模式  此模式让算法的变化独立于使用算法的客户



设计模式 就是和其他开发人员 共享的词汇  交流沟通很容易

设计模式 可以把思考架构的层次提高到模式层面 而不是仅停留在琐碎的对象上。

高内聚
低耦合

动态和松耦合


不自是模式名称，而是一整套模式背后所象征的质量 特性 和约束
更少的词汇做更充分的沟通
使用模式谈论软件系统

初级开发人员
有经验的开发人员
高级开发人员

建立了一个模式使用者的社区

使用别人设计好的库和框架  利用库 框架 他们的API编译成我们的程序

应用 组织成容易了解 容易维护 具有弹性的架构  所以需要设计模式


模式不过是利用OO设计原则

封装 抽象 继承 多态 

面向对象开发
只知道OO概念，不能自动设计出 弹性的 可复用的 可维护的系统


P32!!!!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=======================================================
chap2 观察者模式
观察者 消息灵通
下一代 气象观测站

插件

回调函数
当新的测量数据备妥时， measurementsChanged()方法会被调用  不在乎如何调用的，只在乎它被调用了

一旦WeatherData有新数据，这些布告必须马上更新。
此系统必须可以扩展

public class WeatherData{
    //实例变量
    public void measurementsChanged(){
        get
        update
    }
}

实现有什么不对
概念和原则
针对具体实现编程  VS 针对接口编程
.update(temp, humidity, pressure)

先看观察者模式
再看如何应用到此气象观测站

--认识观察者模式
报纸和杂志订阅
出版者+订阅者=观察者模式
subject+observer
主题对象管理某些数据 +   观察者 注册 订阅 主题 以遍在主题数据改变是能够收到更新

讽刺短剧 后泡沫时期的软件工程师
java程序员

类比
定义了对象之间的一对多依赖



实现观察者模式的方法不止一种
以包含subject和observer接口的类设计的做法最常见

--定义观察者模式 类图

所有潜在的观察者必须实现此观察者接口 update方法

一个具体主题总是实现主题接口
观察者必须注册具体主题 以便接收更新

相比于许多对象控制同一份数据来，这样可以得到更干净的OO设计

--松耦合的威力

两个对象松耦合，仍然可以交互，不太清楚彼此的细节

主题只需要知道 观察者实现了某个接口。

在新的类里实现此接口 注册为观察者  主题不需要修改  主题只会发送通知给所有实现了观察者接口的对象

改变一方 不影响另一方，松耦合  之间的接口被遵守


如何使用观察者模式

布告板的类不一样，但是接口一样

先自己实现
然后java为观察者模式提供了内置的支持

布告板的构造器里注册观察者。


--启动气象站

一段代码将一切连接起来
确定每个组件都能通过配置文件来达到容易 插拔 。

观察者 拉数据 VS 主题推送数据

java内置的observer模式 两种做法都支持

--使用java内置的观察者模式

java API有内置的观察者模式 使用方便 许多功能事先准备好了。
push  pull

扩展 继承

WeatherData扩展了Observable主题

扩展就是继承

--java内置的观察者模式是如何运作的

如何拉数据
setChanged() 方法用来标记状态已经改变的事实。
changed标志的当前状态
--利用内置的支持重做气象站

注册 添加 通知的相关代码删除


548-B


548  5051




































https://www.cnblogs.com/wanggary/category/294620.html
c++ 设计模式实现




























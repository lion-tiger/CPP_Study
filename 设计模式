

chap01      P2
模拟鸭子应用
Joe SimDuck
标注的OO技术 系统内部设计

鸭子超类 各种鸭子继承此超类

父类 共性
子类 个性

抽象display
头脑风暴会议

经理 主管 程序员

叫 游泳  飞

父类 有飞的方法

不是所有的子类 能飞

父类中加上方法 不是所有的子类都有这个方法

对代码所做的局部修改，影响层面不只是局部

设计
当涉及到维护时， 为了复用目的使用的继承 结局并不完美

子类覆盖父类的方法

========================
利用接口    
interface

更新产品

检查可能需要覆盖fly 和 quark方法

fly和quark从超类中提取出来，  放到接口中


需要一个更清晰的方法  让某些鸭子 可飞 可叫


接口 的代码不能复用！

采用良好的OO软件设计原则！！

一种建立软件的方法

工作 构建 编程语言

继承不能很好的解决问题


java接口不具有实现代码，所以继承接口无法达到代码的复用 == 无论何时需要修改fly行为时，必须往下追踪每一个定义此行为的类中修改它，
一不小心，会造成新的错误。


有一个设计原则  需要变化的代码独立出来，独立封装出来，  不要和不需要变化的代码混在一起

系统中的某部分改变不会影响其他部分

结果就是 代码变化引起的不经意后果变少，系统变的更有弹性


分开变化和不会变化的部分

duck类的  fly quack 会随着鸭子的不同而改变


设计鸭子的行为
如何设计行为的类呢？

一切有弹性


java接口？？？

指定行为到鸭子的实例？  让鸭子的行为动态改变
鸭子类中包含设定行为的方法 运行时动态改变绿头鸭的飞行行为

设计原则： 针对接口编程 而不是针对实现编程

接口代表行为 行为的每个实现 实现其中的一个接口

由行为类 而不是 duck类 实现行为接口

鸭子的子类 使用接口所表示的行为，  具体行为编写在了实现行为的类中



flybehavior设计成接口  抽象类

针对接口编程


抽象超类型可以是接口 也可以是抽象类

对应的类负责实现具体的行为

行为与鸭子类无关

实现鸭子的行为 --》 整合鸭子的行为

不在乎接口的对象具体是什么，直观新对象知道如何quack() 就够了。

行为设定成具体的类   运行时在构造函数里指定具体的类



chap01      P2
模拟鸭子应用
Joe SimDuck
标注的OO技术 系统内部设计

鸭子超类 各种鸭子继承此超类

父类 共性
子类 个性

抽象display
头脑风暴会议

经理 主管 程序员

叫 游泳  飞

父类 有飞的方法

不是所有的子类 能飞

父类中加上方法 不是所有的子类都有这个方法

对代码所做的局部修改，影响层面不只是局部

设计
当涉及到维护时， 为了复用目的使用的继承 结局并不完美

子类覆盖父类的方法

========================
利用接口    
interface

更新产品

检查可能需要覆盖fly 和 quark方法

fly和quark从超类中提取出来，  放到接口中


需要一个更清晰的方法  让某些鸭子 可飞 可叫


接口 的代码不能复用！

采用良好的OO软件设计原则！！

一种建立软件的方法

工作 构建 编程语言

继承不能很好的解决问题


java接口不具有实现代码，所以继承接口无法达到代码的复用 == 无论何时需要修改fly行为时，必须往下追踪每一个定义此行为的类中修改它，
一不小心，会造成新的错误。


有一个设计原则  需要变化的代码独立出来，独立封装出来，  不要和不需要变化的代码混在一起

系统中的某部分改变不会影响其他部分

结果就是 代码变化引起的不经意后果变少，系统变的更有弹性


分开变化和不会变化的部分

duck类的  fly quack 会随着鸭子的不同而改变


设计鸭子的行为
如何设计行为的类呢？

一切有弹性


java接口？？？

指定行为到鸭子的实例？  让鸭子的行为动态改变
鸭子类中包含设定行为的方法 运行时动态改变绿头鸭的飞行行为

设计原则： 针对接口编程 而不是针对实现编程

接口代表行为 行为的每个实现 实现其中的一个接口

由行为类 而不是 duck类 实现行为接口

鸭子的子类 使用接口所表示的行为，  具体行为编写在了实现行为的类中



flybehavior设计成接口  抽象类

针对接口编程


抽象超类型可以是接口 也可以是抽象类

对应的类负责实现具体的行为

行为与鸭子类无关

实现鸭子的行为 --》 整合鸭子的行为

不在乎接口的对象具体是什么，直观新对象知道如何quack() 就够了。

行为设定成具体的类   运行时在构造函数里指定具体的类

=================================================

动态设定行为
P20  未代码实现！！！！

================================================

封装行为的大局观
鸭子模拟器
整体格局

整个重新设计后的类结构

一组行为 --》 一族算法

注意类关系

有一个  has a   组合
是一个  is  a   继承

组合 继承

提高可维护性 可扩展性上的复用程度

策略模式  此模式让算法的变化独立于使用算法的客户



设计模式 就是和其他开发人员 共享的词汇  交流沟通很容易

设计模式 可以把思考架构的层次提高到模式层面 而不是仅停留在琐碎的对象上。

高内聚
低耦合

动态和松耦合


不自是模式名称，而是一整套模式背后所象征的质量 特性 和约束
更少的词汇做更充分的沟通
使用模式谈论软件系统

初级开发人员
有经验的开发人员
高级开发人员

建立了一个模式使用者的社区

使用别人设计好的库和框架  利用库 框架 他们的API编译成我们的程序

应用 组织成容易了解 容易维护 具有弹性的架构  所以需要设计模式


模式不过是利用OO设计原则

封装 抽象 继承 多态 

面向对象开发
只知道OO概念，不能自动设计出 弹性的 可复用的 可维护的系统


P32!!!!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=======================================================
chap2 观察者模式
观察者 消息灵通
下一代 气象观测站

插件

回调函数
当新的测量数据备妥时， measurementsChanged()方法会被调用  不在乎如何调用的，只在乎它被调用了

一旦WeatherData有新数据，这些布告必须马上更新。
此系统必须可以扩展

public class WeatherData{
    //实例变量
    public void measurementsChanged(){
        get
        update
    }
}

实现有什么不对
概念和原则
针对具体实现编程  VS 针对接口编程
.update(temp, humidity, pressure)

先看观察者模式
再看如何应用到此气象观测站

--认识观察者模式
报纸和杂志订阅
出版者+订阅者=观察者模式
subject+observer
主题对象管理某些数据 +   观察者 注册 订阅 主题 以遍在主题数据改变是能够收到更新

讽刺短剧 后泡沫时期的软件工程师
java程序员

类比
定义了对象之间的一对多依赖



实现观察者模式的方法不止一种
以包含subject和observer接口的类设计的做法最常见

--定义观察者模式 类图

所有潜在的观察者必须实现此观察者接口 update方法

一个具体主题总是实现主题接口
观察者必须注册具体主题 以便接收更新

相比于许多对象控制同一份数据来，这样可以得到更干净的OO设计

--松耦合的威力

两个对象松耦合，仍然可以交互，不太清楚彼此的细节

主题只需要知道 观察者实现了某个接口。

在新的类里实现此接口 注册为观察者  主题不需要修改  主题只会发送通知给所有实现了观察者接口的对象

改变一方 不影响另一方，松耦合  之间的接口被遵守


如何使用观察者模式

布告板的类不一样，但是接口一样

先自己实现
然后java为观察者模式提供了内置的支持

布告板的构造器里注册观察者。


--启动气象站

一段代码将一切连接起来
确定每个组件都能通过配置文件来达到容易 插拔 。

观察者 拉数据 VS 主题推送数据

java内置的observer模式 两种做法都支持

--使用java内置的观察者模式

java API有内置的观察者模式 使用方便 许多功能事先准备好了。
push  pull

扩展 继承

WeatherData扩展了Observable主题

扩展就是继承

--java内置的观察者模式是如何运作的

如何拉数据
setChanged() 方法用来标记状态已经改变的事实。
changed标志的当前状态
--利用内置的支持重做气象站

注册 添加 通知的相关代码删除

设计原则 针对接口编程 而不是针对实现编程

可观察者是一个类 而不是一个接口

java不支持多重继承

Observable是一个类不是一个接口
继承类
实现接口

setChanged() 被保护起来了 只能继承observable类 才能用setChanged()
否则你无法创建observable实例 并组合到你自己的对象中来
设计原则 多用组合 少用继承

javaBeans  Swing自行探索这些api

观察者模式的代表人物MVC


ls


548-B

2_observer_C  example  Swing!!
548  5051
==============================================================
chap3 装饰着模式
装饰对象
运行时扩展  比编译时的继承威力更大
给爱用继承的人 一个全新的设计眼界
典型的继承滥用问题
对象组合的方式 做到在运行时装饰类
starbuzz  更新订单系统 以合乎他们的饮料供应要求

原先的类设计

利用实例变量和继承

思考设计 将来可能出现的变化，看出这种方法有一些潜在的问题
子类调用父类的cost

最优弹性和最好维护的设计  继承不能满足

组合composition和委托delegation 可以在运行时具有继承行为的效果

利用组合的做法扩展对象的行为 运行时动态的扩展

新职责 加到对象上 不用修改原来的代码


通过动态的组合对象 新的代码实现新的功能，而不影响旧的代码。
既然没有改变既有的代码，引进bug或者产生意外副作用的机会大幅度减少！！

设计原则  对扩展开放 对修改关闭


遵循 开放-关闭原则 通常会引入新的抽象层次，增加代码的复杂度

设计OO系统的设计经验
多看例子！！！！

-- 认识装饰者模式
20171215

设计原则 具体实现

已经了解利用继承无法完全解决问题


基类加入新的功能不适用于所有的子类！！

对象   以焦糖对象装饰他  cost方法，依赖委托将调料的价钱加上去

装饰 委托 包装

装饰着和被装饰着有共同的父类
一个或者多个装饰者包装一个对象
原始对象 被包装的 场合

对象可以任何时候被装饰，可以运行时 动态的 不限量

看装饰者模式定义 写一些代码

装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

如何在实现中实际应用它



类图！！！！ P91

装饰者和被装饰者必须是一样的类型 继承同样的父类！！
  利用继承达到模式匹配 而不是利用继承获得行为
  
  
如果使用继承

getDescription已经在父类中实现
cost抽象接口函数  必须在子类在子类中实现
所有的装饰者必须重新实现getDescription()

description实例变量继承自父类

设置饮料名称 写了一个构造器


利用装饰者模式设计出的灵活系统

重新思考应用架构

代码依赖于具体的组件类型
只有针对抽象组件类型编程时 才不会因为装饰者受到影响



工厂 生成器

--真实世界的装饰者
java.io包内的类太多了。

一个典型的对象集合 用装饰者将功能结合起来 以读取文件数据

--编写自己的java io装饰者
编写自己的输入装饰者！！

依赖特定类型的代码导入装饰者 会引入问题

装饰者模式适合建立有弹性的设计 维持开放-关闭原则

要点！！

组合和委托 可以用于在运行时动态的加上新的行为！！！！


=====================================================
chap4 工厂模式

烘烤某些松耦合的OO设计

除了使用new操作符之外，还有更多制造对象的方法

实例化这个活动不应该总是公开的进行 初始化造成耦合问题

工厂模式如何从复杂的依赖中 解困


new
不该针对实现编程， new就是针对实现编程的

new代表具体

new实例化具体的一个类 是实现 不是接口


代码绑着具体类会导致代码更脆弱 更缺乏弹性


需要使用接口让代码更有弹性  但还是得建立具体类的实例

一些要实例化的具体的类
代码变化或者修改  代码 维护更新 容易犯错

总是要创建对象  java只提供了一个new关键词创建对象

改变如何影响new的使用！！

针对接口编程，可以隔离掉以后系统可能发生的一大堆改变！！  如果代码是针对接口编写，那么通过多态，可以与任何新类实现该接口
当代码使用大量的具体类时 导致 一旦加入新的具体类，就必须改变代码

原则 对扩展开发 对修改关闭

回到oo设计原则 寻找线索  找出变化的地方，把变化从不变中 分离出来。

如何将实例化具体类的代码从应用中分离，或者封装起来，使其不会干扰应用的其他部分

识别变化的方面
pizza shop 对象村内

为了让系统更有弹性，抽象类 或者接口！！   抽象类或者接口无法直接实例化 需要更多的pizza类型

压力来自于增加更多的pizza类型

实例化具体类时 出现了问题


封装创建对象的代码


把创建对象的代码移到另外一个工厂对象中  新的工厂对象专职创建pizza

工厂对象处理创建对象的细节   有细节有待补充

--简历一个简单pizza工厂

把具体实例化的过程，从客户的代码中删除

工厂定义为一个静态的方法。
为和使用静态工厂 因为不需要使用创建对象的方法实例化对象 ？？
缺点是 不能通过继承来改变创建方法的行为？？

把new操作符替换为工厂对象的创建方法，不在使用具体实例化

组合可以在运行时动态改变行为！？？

把编程习惯误认为是工厂模式
简单工厂
新的pizza店 类图

建立一个框架


第一步 简单工厂
第二部 另外两种工厂模式

允许子类做决定！


子类如何做决定？？


--声明一个工厂方法
有一个对象负责所有具体类的实例化  --》 一群子类负责实例化

子类在createPizza方法中处理对象的实例化

工厂方法处理对象的创建，讲此行为封装在子类中。这样 客户程序中关于超类的代码就和子类创建对象的代码解耦


--认识工厂方法模式的时刻终于到了。

所有工厂模式用来封装对象的创建



另一个观点  平行的类层级



讲客户代码和真实的实现解耦

--一个很依赖的pizza store

看看对象依赖~


类的实现   pizza具体实现的任何改变都会影响到pizza store
依赖倒置原则： 要依赖抽象 不要依赖具体类    《==》 针对接口编程 不针对实现编程
不能让高层组件依赖于低层组件 都应该依赖于抽象

对设计的思考方式！

将这些方针内化为思考的一部分
不加思索的实例化字符创对象

--如何处理原料家族
--建造原料工厂
先为工厂定义一个接口，改接口负责创建所有的原料~

--重做pizza
工厂生产高质量原料

代码从实际的产品中解耦了。


A  简单工厂
B  工厂方法模式
C  抽象工厂模式


javac WeatherStation.java -Xlint











jibin
--design 不要纠结于语法！！！！
父类与子类的方法名 要完全一致！！！！





































https://www.cnblogs.com/wanggary/category/294620.html
c++ 设计模式实现





==========================================================
20180102
chap5 单件模式
单例模式

设计简单 实现复杂
只能有一个实例的对象

程序员之间的约定， 利用全局变量 java静态变量
更好的方法，模式经得起时间考验  单例模式确保只有一个实例会被创建

全局的 访问点，和全局变量一样方便，没有全局变量的缺点。


利用单例模式，需要的时候创建它。

静态变量 静态方法 访问修饰符
如何保证对象只能被实例化一次？

和实现有关 JVM 在用到的时候才创建对象！！



私有构造器的类 不能被实例化
有可以使用私有构造器的对象吗

159 2564 0830

静态方法是类的方法 要用类名。
经典的单例模式的实现。。。

如果不需要实力 就不会产生 延迟实例化？？

任何时刻都有一个对象 确保程序中使用的全局资源只有一份 管理共享资源 数据库连接 线程池

没有公开的构造器 私有的构造器 无法实例化

定义单例模式
确保一个类只有一个实例，并提供一个全局访问点


经典实现  在多线程的时候 出现了问题

处理多线程  getInstance变成异步的  不会有2个线程同时进入这个方法！！！！

改善多线程！  为了符合大多数java应用程序

改进一  同步getInstance方法 但是影响性能
改进二  急切创建实例而不是延迟创建
改进三  双重加锁

volatile
synchronized

复杂的初始化！  静态初始化的控制权在java手上 混乱！  初始化次序的bug
类的单例 VS 对象的单例！



自行指定类加载器

网络连接被重置？  1.2后不在需要一个全局引用来保护单例

一个类一个责任！

P185 三个问题？
单例模式的构造器是私有的  不能用私有的构造器扩展类    基类必须实现注册表功能？？

==================================================================
chap6 命令模式
封装调用
20180102

把方法调用封装起来

封装方法调用
接口实现分离
如何使用
如何实现
家电自动化遥控器API
可控制装置
？
shaipie  --> sharpie
光盘上面的厂商类


你 对 即将设计的对象的接口有些想法




https://kb.cnblogs.com/page/531409/

























http://blog.csdn.net/column/details/design.html
设计模式cpp实现 总


http://blog.csdn.net/wuzhekai1985/article/details/6660462
工厂模式


http://blog.csdn.net/silangquan/article/details/20492293
工厂模式3中实现 肥皂

http://www.weixueyuan.net/cpp/shejimoshi/
设计模式学院


http://blog.csdn.net/hackbuteer1/article/details/7475622
浅谈c++多态
基类指针指向子类对象 虚函数列表
区别重载和隐藏


三、相似概念
   1、多态性 
  指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 
  a、编译时多态性：通过重载函数实现 
  b、运行时多态性：通过虚函数实现。 
  2、虚函数 
  虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）
  3、抽象类 
  包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。



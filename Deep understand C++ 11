


chap 7 为改变思考方式而改变
成熟的语言，语言的核心部分的改变遵循一贯的设计思想。
lambda
7.1 指针空值nullptr
0--》null --》nullptr

变量要初始化 尤其是指针变量

位初始化的野指针 难于调试的用户程序的根源
写地址为0的内存空间  运行时退出
int *my_ptr = 0
int *my_ptr = NULL;
NULL是一个宏定义
stddef.h    字面常量0  无类型指针(void *）0 常量

函数重载的例子






7.2 默认函数的控制
C++中定义声明的类，编译器会默认帮助程序员生成一些 未定义的成员函数
默认函数

自定义类型的成员函数

构造函数
拷贝构造函数
拷贝赋值函数
移动构造函数
移动拷贝函数
析构函数

为自定义类型 提供 全局默认操作符函数
, & && * -> ->* new delete



实现了这些函数的自定义版本 编译器不会为该类自动生成默认版本

声明了带参数的构造函数版本 必须声明不带单数的版本已完成无参的变量初始化



一旦声明了自定义版本的构造函数，则有可能导致我们定义的类型不再是POD的







7.3 lambda 函数
数理逻辑或者计算机科学  一种匿名函数
lambda演算 编程语言理论的研究成果
基于lambda演算的 LISP语言     FORTRAN --》 LISP   广泛有应用于人工智能的研究领域

软件开发的角度 以lambda为基础的 函数式编程 命令式编程 面向对象编程  编程泛型   C# PHP JavaScript

g++ -std=c++11 aa.cpp

lambda函数不需要定义函数名 追踪返回类型的方式声明其返回类型
lambda函数的语法定义规则
[](int x,int y)-> int{return x+y;};
捕捉列表  []是lambda引出符  捕捉列表会能够捕捉上下文中的的变量供lambda函数使用。
参数列表
默认情况下 lambda总是一个const函数
返回类型 用追踪返回类型的形式声明函数的返回类型
还可以使用所有捕获的变量

[] {};
各种各样的lambda函数

int main()
{
    [] {};
    int a = 3;
    int b = 4;
    [=]{return a+b;};
    auto func1 = [&](int c){b = a+c;};
    auto func2 = [=,&b](int c)->{return b+=a+c;};
    
}



lambda函数可以通过捕捉列表访问一些上下文中的数据

使用方式  传值还是传引用

boys 和 girls 看做是lambda函数的初始状态   其运算时基于初始状态进行的运算 与函数简单基于参数的运算是不同的

[var]
[=]
[&var]
[&]
[this]

父作用域   enclosing scope  包含lambda函数的语句块
[=,&a,&b]
[&,a,this]
捕捉列表不允许变量重复传递

lambda函数父作用于中的所有自动变量都以值的方式捕捉了。

- lambda与仿函数
好的编程语言都有库的支持
C++语言在标准程序库STL中向用户提供了一些基本的数据结构及一些基本的算法

函数对象 仿函数  重定义了成员函数opeartor() 的一种自定义类型对象


类的opeartor() 被重载  跟函数调用一样的形式  a不是函数名称 不是类名称而是对象名称


相比于函数 仿函数可以有初始状态 class定义私有成员，声明对象的时候对其初始化。
私有成员的状态就是仿函数的初始状态。

通过带状态的仿函数，

仿函数和lambda函数 在实现之间存在着一种默契呢。

lambda捕捉了tax_rate变量
仿函数以tax_rate初始化类
参数传递上，两者保持一致。
除去在语法层面上的不同， 相同的内涵
捕捉一些变量作为初始状态，并接受参数进行运算

仿函数是编译器实现lambda的一种方式 通常编译器会把lambda函数转化成为一个仿函数对象。

仿函数被防范的用语STL中，lambda在C++11标准库中广泛的使用。  书写简单 就地定义

7.3.4
auto关键字推导出 validate是lambda匿名函数
lambda函数等同于一个局部函数

C/C++语言标准不允许局部函数存在
lambda 类似于局部函数 但不是

全局静态函数 私有成员函数

复杂代码的快速开发
C++11之前 程序员只能编写类来模拟局部函数
常量性的例子 常量的值 由自己初始化状态决定
















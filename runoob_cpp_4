24 C++ 类和对象
c++在c的基础上增加了面向对象编程
C++支持面向对象程序设计
类是c++的核心特性 通常被称为用户定义的类型

类用于指定对象的形式 包含数据表示法和用于处理数据的方法
类中的数据和方法称为类的成员
函数在一个类 被称为类的成员


属性 方法 = 数据 函数

C++类定义
定义一个类 定义对象的蓝图 本质上是定义一个数据类型的蓝图 没有定义任何数据 定义了类的对象包括什么 以及可以在这个对象上执行哪些操作

class 类
class BOOK{

};        类的定义必须跟着一个分号或者一个生命列表

class Box{
public:
    double length;
    double breadth;
    double height;
};
public类成员的访问属性

定义C++对象     类提供了对象的蓝图 对象是根据类来创建的
声明类的对象，像声明基本类型的变量
int a;
Box b;
对象box1 box2 都有各自的数据成员

访问数据成员
类的对象的公共数据成员  成员访问运算符

私有成员和受保护的成员不能使用直接成员访问运算符来直接访问。

类 对象详解
1 成员函数
把定义和原型写在类定义内部的函数  类定义中的其他变量一样
使用成员函数访问类的成员，而不是直接访问这些类的成员
范围解析运算符::
类名
对象名

成员函数声明
成员函数定义

类名VS对象名

2 类 访问修饰符
public private protected
数据封装是面向对象编程的一个重要特点
防止函数直接访问类类型的内部成员
类成员的访问限制

private成员变量或者成员函数 在类的外部是不可访问的   不可查看的 只有类和友元函数可以访问私有成员


一般在私有区域定义数据 共有区域定义相关函数 类的外部可以调用这些函数

protected与 私有相似，保护成员在类的派生类子类中可访问。

继承中的特点：
private成员只能被本类成员 和友元访问，不能被派生类访问
protected成员可以被派生类访问


3 构造函数与析构函数
构造函数 特殊的成员函数 新建对象时自动执行
无返回值  一般用于给某些成员变量设置初始值


带参数的构造函数

使用初始化列表来初始化字段：
C::C(double a,double b,double c):X(a),Y(b),Z(c)
{

}

类的析构函数：
类的析构函数特殊的成员函数，每次删除所创建的对象时执行 没有返回值 没有参数
有助于在跳出程序时  前释放  关闭文件释放内存


成员函数定义： 包括构造函数



4 拷贝构造函数
特殊的构造函数 创建对象时，同一类中之前创建的对象来初始化新的对象

如果类中没有定义拷贝构造函数，编译器会自行定义一个。

如果类中带有指针变量，并有动态内存分配，必须有一个拷贝构造函数。
A(const A& a)
{
}  a是一个对象引用，该对象用于初始化另一个对象


拷贝构造函数的调用时机
1 对象以值的方式传入函数参数
拷贝构造函数有单个形参   A(const A &a);

int a = 5    A a = 2  拷贝初始化 调用拷贝构造函数
int a(5)     A a(2)   直接初始化 调用构造函数

5 C++友元函数

类的友元函数定义在类的外部，但是有权使用类的私有和保护成员
友元函数的原型在类的定义中出现过，但是不是成员函数

友元   友元函数 友元类
友元函数不是类的成员函数

6 内联函数
内联函数和类一起使用 编译时 编译器将函数的代码副本 放置在每个调用函数的地方

对内联函数的任何修改， 重新编译函数的客户端

函数名前放置关键字 inline， 调用函数之前要对函数进行定义。 如果已定义的函数多于一行，编译器会忽略inline限定符

在类中定义的函数都是内联函数 即使没有inline关键字。

空间换时间

7 C++this指针
每一个对象都能通过this指针访问自己的地址 this指针是多有成员函数的隐藏参数
成员函数内部用this指针指向调用对象

友元函数没有this指针，因为友元函数不是类的成员 只有成员函数才有this指针


8 类的指针
指向类的指针和指向结构的指针类似  
类可以看成带有函数的结构

指向C++的指针与指向结构的指针类似
与所有的指针一样，必须在使用指针之前进行初始化




9 C++类的静态成员
类的数据成员和函数成员 都可以被声明为静态的
static
声明类的成员为静态时，意味着无论创建多少个类的对象，静态成员都只有一个副本

静态成员在所有对象中是共享的
如果不存在其他的初始化语句，
创建第一个对象时，所有的静态数据都会被初始化为0，
不能在类的定义中 初始化静态成员变量

初始化类的静态成员

如果把函数成员声明为静态的，把函数和类的任何特定对象独立开来，
静态成员函数即使在类对象不存在的情况下，也能被调用。
静态函数只要在用类名加 范围解析运算符::就可以访问


静态成员函数只能访问静态成员变量  其他静态成员函数 和类外部的其他函数


静态成员变量在类中仅仅是声明 不是定义 要在类外定义。 实际上是给静态成员变量分配内存。
变量声明
变量定义             分配内存
变量初始化           赋一个初始值





===========================================
C++继承
面向对象程序设计 最重要的概念是继承 重用代码 提高执行时间的效果

基类就是父类
派生类是子类

多继承 
类派生列表指定基类

访问控制和继承

派生类可以访问基类的所有的非私有成员

一个派生类 继承了所有的基类方法：
除了 1 构造函数析构函数拷贝构造函数
     2 基类的重载运算符
     3 基类的友元函数
     
     
     
 继承类型
     
     
 多继承
   多继承 一个子类有多个父类 继承了多个父类的特性
   
   
   虚继承
   虚函数
 
虚继承  在创建对象的时候会创建一个虚表 在创建父类对象的时候



chap26 C++重载运算符和重载函数






















6538 小米
9835 5s



























std:bind
boost::spply_visitor





struct UeIdExtractingEventVisitor : boost::static_visitor<>
{
    UeIdExtractingEventVisitor(std::function<user_management::Users&()> users) : users{std::move(users)}
    {
    }
    template <typename T>
    void operator()(const T& msg)
    {
        users().handleMessage(std::make_pair(msg.ueFsId, msg));
    }


















http://www.jellythink.com/archives/82
C++ 单例模式
日志功能 日志模块
构造一个日志模块的全局变量

使用全局变量 不符合面向对象的封装原则
在纯面向对象的语言java c#中 就没有纯粹的全局变量

GOF 《设计模式 可复用面向对象软件的基础》
保证一个类只有一个实例 提供一个访问他的全局访问点
为了防止在外部调用类的构造函数而构造实例，需要将类的构造函数方位权限标记位protecetd或private

1 多线程的问题
2 两次m_Instance == NULL 判断 借鉴Java的单例模式 双检锁
3 if 进行大数据操作，上锁解锁 讲成为一个性能瓶颈。

静态初始化在 程序开始 进入到主函数之前 主线程一单线程方式完成了初始化。 静态初始化实例保证了线程安全性。  实例的销毁

new 操作符 实例化对象

犹于 怕忘记delete操作 所以有了智能指针

客户端开发

类中 文件句柄 数据库连接   必须手动释放


必须熟练了各种设计模式的特点
才能更好的在实际项目中运用  单例模式和工厂模式

程序运行结束时，系统会调用Singleton的静态成员GC的析构函数，改析构函数会进行资源的释放

剖析问题时，喜欢剖析到问题的根上，绝不停留在表面。
程序结束的时候，会自动析构所有的 全局变量  也会析构所有类的静态成员变量


我剖析问题时，喜欢剖析到问题的根上去，绝不糊涂的停留在表面。
由于程序在结束的时候，系统会自动析构所有的全局变量，实际上，系统也会析构所有类的静态成员变量，就像这些静态变量是全局变量一样。
我们知道，静态变量和全局变量在内存中，都是存储在静态存储区的，所以在析构时，是同等对待的。




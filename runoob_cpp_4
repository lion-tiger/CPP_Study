24 C++ 类和对象
c++在c的基础上增加了面向对象编程
C++支持面向对象程序设计
类是c++的核心特性 通常被称为用户定义的类型

类用于指定对象的形式 包含数据表示法和用于处理数据的方法
类中的数据和方法称为类的成员
函数在一个类 被称为类的成员


属性 方法 = 数据 函数

C++类定义
定义一个类 定义对象的蓝图 本质上是定义一个数据类型的蓝图 没有定义任何数据 定义了类的对象包括什么 以及可以在这个对象上执行哪些操作

class 类
class BOOK{

};        类的定义必须跟着一个分号或者一个生命列表

class Box{
public:
    double length;
    double breadth;
    double height;
};
public类成员的访问属性

定义C++对象     类提供了对象的蓝图 对象是根据类来创建的
声明类的对象，像声明基本类型的变量
int a;
Box b;
对象box1 box2 都有各自的数据成员

访问数据成员
类的对象的公共数据成员  成员访问运算符

私有成员和受保护的成员不能使用直接成员访问运算符来直接访问。

类 对象详解
1 成员函数
把定义和原型写在类定义内部的函数  类定义中的其他变量一样
使用成员函数访问类的成员，而不是直接访问这些类的成员
范围解析运算符::
类名
对象名

成员函数声明
成员函数定义

类名VS对象名

2 类 访问修饰符
public private protected
数据封装是面向对象编程的一个重要特点
防止函数直接访问类类型的内部成员
类成员的访问限制

private成员变量或者成员函数 在类的外部是不可访问的   不可查看的 只有类和友元函数可以访问私有成员


一般在私有区域定义数据 共有区域定义相关函数 类的外部可以调用这些函数

protected与 私有相似，保护成员在类的派生类子类中可访问。

继承中的特点：
private成员只能被本类成员 和友元访问，不能被派生类访问
protected成员可以被派生类访问


3 构造函数与析构函数
构造函数 特殊的成员函数 新建对象时自动执行
无返回值  一般用于给某些成员变量设置初始值


带参数的构造函数

使用初始化列表来初始化字段：
C::C(double a,double b,double c):X(a),Y(b),Z(c)
{

}

类的析构函数：
类的析构函数特殊的成员函数，每次删除所创建的对象时执行 没有返回值 没有参数
有助于在跳出程序时  前释放  关闭文件释放内存


成员函数定义： 包括构造函数



4 拷贝构造函数
特殊的构造函数 创建对象时，同一类中之前创建的对象来初始化新的对象

如果类中没有定义拷贝构造函数，编译器会自行定义一个。

如果类中带有指针变量，并有动态内存分配，必须有一个拷贝构造函数。
A(const A& a)
{
}  a是一个对象引用，该对象用于初始化另一个对象


拷贝构造函数的调用时机
1 对象以值的方式传入函数参数
拷贝构造函数有单个形参   A(const A &a);

int a = 5    A a = 2  拷贝初始化 调用拷贝构造函数
int a(5)     A a(2)   直接初始化 调用构造函数

5 C++友元函数

类的友元函数定义在类的外部，但是有权使用类的私有和保护成员
友元函数的原型在类的定义中出现过，但是不是成员函数

友元   友元函数 友元类
友元函数不是类的成员函数

6 内联函数
内联函数和类一起使用 编译时 编译器将函数的代码副本 放置在每个调用函数的地方

对内联函数的任何修改， 重新编译函数的客户端

函数名前放置关键字 inline， 调用函数之前要对函数进行定义。 如果已定义的函数多于一行，编译器会忽略inline限定符

在类中定义的函数都是内联函数 即使没有inline关键字。

空间换时间

7 C++this指针
每一个对象都能通过this指针访问自己的地址 this指针是多有成员函数的隐藏参数
成员函数内部用this指针指向调用对象

友元函数没有this指针，因为友元函数不是类的成员 只有成员函数才有this指针


8 类的指针
指向类的指针和指向结构的指针类似  
类可以看成带有函数的结构

指向C++的指针与指向结构的指针类似
与所有的指针一样，必须在使用指针之前进行初始化




9 C++类的静态成员
类的数据成员和函数成员 都可以被声明为静态的
static
声明类的成员为静态时，意味着无论创建多少个类的对象，静态成员都只有一个副本

静态成员在所有对象中是共享的
如果不存在其他的初始化语句，
创建第一个对象时，所有的静态数据都会被初始化为0，
不能在类的定义中 初始化静态成员变量

初始化类的静态成员

如果把函数成员声明为静态的，把函数和类的任何特定对象独立开来，
静态成员函数即使在类对象不存在的情况下，也能被调用。
静态函数只要在用类名加 范围解析运算符::就可以访问


静态成员函数只能访问静态成员变量  其他静态成员函数 和类外部的其他函数


静态成员变量在类中仅仅是声明 不是定义 要在类外定义。 实际上是给静态成员变量分配内存。
变量声明
变量定义             分配内存
变量初始化           赋一个初始值





===========================================
C++继承
面向对象程序设计 最重要的概念是继承 重用代码 提高执行时间的效果

基类就是父类
派生类是子类

多继承 
类派生列表指定基类

访问控制和继承

派生类可以访问基类的所有的非私有成员

一个派生类 继承了所有的基类方法：
除了 1 构造函数析构函数拷贝构造函数
     2 基类的重载运算符
     3 基类的友元函数
     
     
     
 继承类型
     
     
 多继承
   多继承 一个子类有多个父类 继承了多个父类的特性
   
   
   虚继承
   虚函数
 
虚继承  在创建对象的时候会创建一个虚表 在创建父类对象的时候



chap26 C++重载运算符和重载函数
C++允许在同一个作用域中的某个函数 运算符指定多个定义
函数重载
运算符重载

重载声明
选择合适的重载函数或者重载运算符的过程，成为重载决策


C++中的函数重载
同一个作用域内，声明几个功能类似的同名函数 形参不同

C++中的运算符重载
可以重定义或者重载大部分 c++内置运算符  使用自定义的运算符。
重载的运算符是带有特殊名称的函数。
函数名  operator=
重载运算符有一个返回类型和一个参数列表


普通的非成员函数 VS 类的成员函数

可重载运算符和不可重载运算符

空间申请与释放  new  delete  new[] delete[]

其他运算符  () 函数调用
           -> 成员访问
           ->* 成员指针访问
           ,
           []
           
           
运算符重载实例
























6538 小米
9835 5s















chap33 
=============================================================
chap34 C++命名空间     ok
附加信息去问不同库中相同名字的函数 类 变量
使用了明明空间即定义了上下文，本质上，命名空间就是定义了一个范围

定义命名空间
命名空间的定义使用关键字 namespace

命名空间如何为变量 或者函数 等实体 定义范围

using namespace 
using指令也可以指定明明空间中的特定项目。

using指令 引入的名称遵循正常的范围规则， 名称从using指令开始是可见的，直到该范围结束。
在范围以外定义的同名实体是隐藏的


不连续的命名空间
命名空间定义 可以是定义一个新的命名空间，也可以是为已有的明明空间增加新的元素


嵌套的命名空间


====================================================
chap35 C++模板     ok
模板是泛型编程的基础
泛型编程是以一种独立于任何特定类型的方式编写代码

模板是创建泛型类和函数的 蓝图或者公式

库容器  迭代器和算法 都是泛型编程的例子 都是用了模板的概念

每个容器都有一个单一的定义，比如向量  vector
可以定义许多不同类型的向量
vector<int> 
vector<string>


可以使用模板来定义函数和类


函数模板 VS 类模板


函数模板  模板函数
type是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用

泛型类声明的一般形式


===================================================
















==================================================
chap40 C++ STL教程  ok

C++模板的概念，
C++ STL标准 模板 库  一套功能强大的C++模板类，
提供了通用的模板 类和函数。
这些模板类 可以实现多种流行的和常用的算法和数据结构  向量 链表 队列 栈
C++标准模板库的核心包括以下三个组件：
容器  管理某一类对象的集合   deque list vector map
算法  算法作用于容器  初始化 排序 搜索 转换
迭代器 便利对象集合的元素  集合可以是容器，也可以使容器的子集

这3个组件都带有丰富的预定义函数  简单的方式处理复杂的任务


向量容器，类似于数组，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求。
使用迭代器iterator访问 便利 值
=================================================
chap41 C++ 标准库 ok
标准函数库  通用的独立的不属于任何类的函数组成的  继承自c语言
面向对象类库  类及相关函数的集合

C++标准库包含了所有的c标准库 为了支持类型安全，做了一定的添加和修改

宽字符函数

标准的C++面向对象类库定义了大量支持一些常见操作的类
I/O
String
value
================================================
chap42 C++有用的资源
C++网站 书籍 文章
===============================================
continue
   more practice needed.














std:bind
boost::spply_visitor





struct UeIdExtractingEventVisitor : boost::static_visitor<>
{
    UeIdExtractingEventVisitor(std::function<user_management::Users&()> users) : users{std::move(users)}
    {
    }
    template <typename T>
    void operator()(const T& msg)
    {
        users().handleMessage(std::make_pair(msg.ueFsId, msg));
    }


















http://www.jellythink.com/archives/82
C++ 单例模式
日志功能 日志模块
构造一个日志模块的全局变量

使用全局变量 不符合面向对象的封装原则
在纯面向对象的语言java c#中 就没有纯粹的全局变量

GOF 《设计模式 可复用面向对象软件的基础》
保证一个类只有一个实例 提供一个访问他的全局访问点
为了防止在外部调用类的构造函数而构造实例，需要将类的构造函数方位权限标记位protecetd或private

1 多线程的问题
2 两次m_Instance == NULL 判断 借鉴Java的单例模式 双检锁
3 if 进行大数据操作，上锁解锁 讲成为一个性能瓶颈。

静态初始化在 程序开始 进入到主函数之前 主线程一单线程方式完成了初始化。 静态初始化实例保证了线程安全性。  实例的销毁

new 操作符 实例化对象

犹于 怕忘记delete操作 所以有了智能指针

客户端开发

类中 文件句柄 数据库连接   必须手动释放


必须熟练了各种设计模式的特点
才能更好的在实际项目中运用  单例模式和工厂模式

程序运行结束时，系统会调用Singleton的静态成员GC的析构函数，改析构函数会进行资源的释放

剖析问题时，喜欢剖析到问题的根上，绝不停留在表面。
程序结束的时候，会自动析构所有的 全局变量  也会析构所有类的静态成员变量


我剖析问题时，喜欢剖析到问题的根上去，绝不糊涂的停留在表面。
由于程序在结束的时候，系统会自动析构所有的全局变量，实际上，系统也会析构所有类的静态成员变量，就像这些静态变量是全局变量一样。
我们知道，静态变量和全局变量在内存中，都是存储在静态存储区的，所以在析构时，是同等对待的。




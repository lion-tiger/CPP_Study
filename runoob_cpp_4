24 C++ 类和对象
c++在c的基础上增加了面向对象编程
C++支持面向对象程序设计
类是c++的核心特性 通常被称为用户定义的类型

类用于指定对象的形式 包含数据表示法和用于处理数据的方法
类中的数据和方法称为类的成员
函数在一个类 被称为类的成员


属性 方法 = 数据 函数

C++类定义
定义一个类 定义对象的蓝图 本质上是定义一个数据类型的蓝图 没有定义任何数据 定义了类的对象包括什么 以及可以在这个对象上执行哪些操作

class 类
class BOOK{

};        类的定义必须跟着一个分号或者一个生命列表

class Box{
public:
    double length;
    double breadth;
    double height;
};
public类成员的访问属性

定义C++对象     类提供了对象的蓝图 对象是根据类来创建的
声明类的对象，像声明基本类型的变量
int a;
Box b;
对象box1 box2 都有各自的数据成员

访问数据成员
类的对象的公共数据成员  成员访问运算符

私有成员和受保护的成员不能使用直接成员访问运算符来直接访问。

类 对象详解
1 成员函数
把定义和原型写在类定义内部的函数  类定义中的其他变量一样
使用成员函数访问类的成员，而不是直接访问这些类的成员
范围解析运算符::
类名
对象名

成员函数声明
成员函数定义

类名VS对象名

2 类 访问修饰符
public private protected
数据封装是面向对象编程的一个重要特点
防止函数直接访问类类型的内部成员
类成员的访问限制

private成员变量或者成员函数 在类的外部是不可访问的   不可查看的 只有类和友元函数可以访问私有成员


一般在私有区域定义数据 共有区域定义相关函数 类的外部可以调用这些函数

protected与 私有相似，保护成员在类的派生类子类中可访问。

继承中的特点：
private成员只能被本类成员 和友元访问，不能被派生类访问
protected成员可以被派生类访问


3 构造函数与析构函数
构造函数 特殊的成员函数 新建对象时自动执行
无返回值  一般用于给某些成员变量设置初始值


带参数的构造函数

使用初始化列表来初始化字段：
C::C(double a,double b,double c):X(a),Y(b),Z(c)
{

}

类的析构函数：
类的析构函数特殊的成员函数，每次删除所创建的对象时执行 没有返回值 没有参数
有助于在跳出程序时  前释放  关闭文件释放内存


成员函数定义： 包括构造函数



拷贝构造函数
特殊的构造函数 创建对象时，同一类中之前创建的对象来初始化新的对象

如果类中没有定义拷贝构造函数，编译器会自行定义一个。

如果类中带有指针变量，并有动态内存分配，必须有一个拷贝构造函数。
A(const A& a)
{
}  a是一个对象引用，该对象用于初始化另一个对象


拷贝构造函数的调用时机
1 对象以值的方式传入函数参数
拷贝构造函数有单个形参   A(const A &a);

int a = 5    A a = 2  拷贝初始化 调用拷贝构造函数
int a(5)     A a(2)   直接初始化 调用构造函数

4 C++友元函数


5 内联函数
内联函数和类一起使用 编译时 编译器将函数的代码副本 放置在每个调用函数的地方





















std:bind
boost::spply_visitor





struct UeIdExtractingEventVisitor : boost::static_visitor<>
{
    UeIdExtractingEventVisitor(std::function<user_management::Users&()> users) : users{std::move(users)}
    {
    }
    template <typename T>
    void operator()(const T& msg)
    {
        users().handleMessage(std::make_pair(msg.ueFsId, msg));
    }


















http://www.jellythink.com/archives/82
C++ 单例模式
日志功能 日志模块
构造一个日志模块的全局变量

使用全局变量 不符合面向对象的封装原则
在纯面向对象的语言java c#中 就没有纯粹的全局变量

GOF 《设计模式 可复用面向对象软件的基础》
保证一个类只有一个实例 提供一个访问他的全局访问点
为了防止在外部调用类的构造函数而构造实例，需要将类的构造函数方位权限标记位protecetd或private

1 多线程的问题
2 两次m_Instance == NULL 判断 借鉴Java的单例模式 双检锁
3 if 进行大数据操作，上锁解锁 讲成为一个性能瓶颈。

静态初始化在 程序开始 进入到主函数之前 主线程一单线程方式完成了初始化。 静态初始化实例保证了线程安全性。  实例的销毁

new 操作符 实例化对象

犹于 怕忘记delete操作 所以有了智能指针

客户端开发

类中 文件句柄 数据库连接   必须手动释放


必须熟练了各种设计模式的特点
才能更好的在实际项目中运用  单例模式和工厂模式

程序运行结束时，系统会调用Singleton的静态成员GC的析构函数，改析构函数会进行资源的释放

剖析问题时，喜欢剖析到问题的根上，绝不停留在表面。
程序结束的时候，会自动析构所有的 全局变量  也会析构所有类的静态成员变量


我剖析问题时，喜欢剖析到问题的根上去，绝不糊涂的停留在表面。
由于程序在结束的时候，系统会自动析构所有的全局变量，实际上，系统也会析构所有类的静态成员变量，就像这些静态变量是全局变量一样。
我们知道，静态变量和全局变量在内存中，都是存储在静态存储区的，所以在析构时，是同等对待的。




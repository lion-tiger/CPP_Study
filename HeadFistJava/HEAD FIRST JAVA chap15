chap15 网络与线程
网络联机
java应用程序向外扩展 并触及其他计算机上的程序
所有网络运作的低层细节都已经由java.net函数库处理好了。

java的一项好处就是 传送与接收网络上的数据只不过是连接上使用不同链接串流的输入输出而已

客户端聊天程序 聊天服务器 传送与接收文字信息

除错抓问题的能力

连接 传送与接收

同时做两件事情

-建立socket连接
socket是个代表两台机器之间网络连接的对象
忽略低层次的细节  低层次的网络设备
端口号 16位整数 识别服务器上的特定程序。
网页服务器 http  80

端口号代表 服务器上执行软件的逻辑识别 只是个逻辑上用来表示应用程序的数字
如果没有端口号，服务器就无法分辨客户端是要连接到哪个应用程序的服务。
对邮件服务器发送http请求   0~1023已经保留给已知的特定服务  网管 端口号 防火墙或者特定的其他的安全控管机制封锁起来

不同的程序不能共享一个端口

--使用buffer read从socket上读取数据

串流来自文件还是socket不关心

PrintWriter  VS BufferedWriter

-编写简单的服务器应用程序
每次只能处理一个请求

-编写聊天客户端程序

同时执行的能力  检查服务器信息的时候不能打算gui的交互

新的线程 thread 一个独立的执行空间stack

java语言内置多线程功能
建立的新的线程对象就会启动新的线程 独立的调用执行空间

线程死亡时，堆栈也就消失 线程的任务=独立线程要跑的代码 
多线程 线程和它的任务


java有多个线程但只有一种thread类。



线程 独立的线程 独立的执行空间  thread  stack
Thread是java.lang这个包中的一个类。
Thread对象代表线程，启动新的线程时建立thread实例。



每个java应用程序会启动一个主线程，将main放在自己的执行空间的最开始处

java虚拟机会负责主线程的启动一级不如垃圾收集所需要的系统用线程

-有一个以上的执行空间代表什么？

java也只是个在低层次操作系统上执行的进程 那个字节码  目前执行空间最上面的会被执行。

-如何启动新的线程
Run拿不了这个接口 

任务是线程在启动时去执行的工作，该任务是新线程空间的第一个方法

java虚拟机的线程调度机制


锁住该对象的线程 放开这个对象 才能继续下去

阻塞 可运行 running

程序设计新手会犯的错误就是在单一的机器上测试多线程程序
平台无关的java应用程序

InterruptedException ex 这个异常是API支持县城建通信的机制

调用sleep强迫此线程进入阻塞等待队列

多线程会产生并发性的问题

并发性问题会引发竞争状态， 竞争状态会引发数据的损毁
两个以上的线程存取单一对象的数据  两个不同执行空间的方法 都在堆上对同一个对象执行get or set

使用synachronized这个关键字来修饰方法是它每次只能被单一的线程存取
不会把锁上到账户本身，会锁上执行银行交易的方法

锁什么东西？ 方法 runnable对象 线程

要保护数据，就要把作用在数据上的方法同步化

对象的锁只会在同步化的方法上 起作用
锁不是在方法上，是在对象上

同步化的目标是要保护重要的数据，锁住的不是数据而是存取数据的方法  java虚拟机自动处理

丢失更新的问题更令人闻风丧胆


非原子性的问题  并行性问题


步骤复杂到无法以单一命令完成时
两个都想把余额递增的线程来展示更新丢失

用同步机制让increament() 方法原子化  可以解决丢失更新问题 其可以让方法中的两个步骤组成不可分割的单元。


导致死锁现象

死锁会发生时因为两个线程互相持有对方正在等待的东西

数据库
其他的应用程序服务器  数据库有与同步化非常相似的上锁机制

《java thread》






















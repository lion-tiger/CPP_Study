CPP_PART4
面向对象编程
模板与泛型编程

C++如何支持面向对象编程和泛型编程
chap15 继承和动态绑定  继承和动态绑定 与数据抽象是面向对象编程的基础
chap16 函数模板和类模板 模板 编写独立于具体类型的泛型类和泛型函数

对C++充分理解
标准库
类型和算法

chap15
面向对象编程
封装  数据抽象
继承
多态  动态绑定

动态绑定使编译器能够在运行时决定使用积累中定义的函数还是派生类中定义的函数
相关但略有不同的概念
面向对象编程  OOP  与这种应用匹配

15.1 面向对象编程 概述
多态性 
C++中 多态性仅用于通过继承而相关联的类型的引用或指针
继承 共享公共的东西 特化本质上不同的东西
函数特化
继承层次
在C++中 基类必须指出希望派生类重定义哪些函数 virtual
定义为virtual   基类希望派生类继承的函数不能定义为虚函数

动态绑定
    使用多态，编写程序使用继承层次中的任一类型的对象，无须关心对象的具体类型
    
    C++中 通过基类的引用 指针 调用虚函数时 发生动态绑定，
    
    
15.2
定义基类和派生类
在继承层次中定义类还需要另外一些特性
基类也有定义其接口和实现的数据和函数成员
继承层次的根类一般需要定义虚析构函数

-基类成员函数
基类通常应将派生类重定义的

private的成员只能有基类的成员或者友元访问
protected成员可以被派生类对象访问 而不能被该类型的普通用户访问

派生类  类派生列表
多继承与单继承

如果想要继承基类的接口 public
派生类可以继承基类的成员 也可以定义自己的附加成员
派生类只定义与基类不同或者扩展的类行为

派生类与虚函数
派生类型必须对想要重新定义的每个继承成员进行生命
派生类中的函数可以使用基类的成员
用作基类的类必须是已定义的
派生类的声明

15.2.4
virtual与其他成员函数
C++中函数调用默认不使用动态绑定

只需要正确的设计和实现类。


非虚函数在编译时就确定调用的函数
覆盖虚函数机制

递归

5 虚函数与默认实参
继承和组合

15.2.6 友元关系与继承


15.2.7
继承与静态成员


15.3 转换与继承
理解基类类类型和派生类类型之间的转换 对于理解面向对象编程正在C++中如何工作的非常关键

派生类类型引用到基类类型引用的自动转换

class Parent{

};
class Child : public Parent{

};

Parent *p;
Child  c;
p=&c;
Parent &conference = c;
编译器不会自动将派生类对象转换为基类类型对象

-引用转换不同于转换对象
    派生类类型的对象传给希望接受基类引用的函数
    void function(Parent& p)
    
    fucntion(c);
    将对象传递给希望金额受引用的函数时，引用直接绑定到该对象   实参是该对象的引用 对象本身未复制
    void function(Parent p)
    function(c);   形参的类型是固定的  该派生类对象的基类部分被复制到形参
    
    
- 用派生类对象对基类对象进行初始化或复制

初始化调用构造函数  复制时调用复制操作符  存在派生类引用到基类引用的转换  复制控制成员可用于从派生类对象对基类对象进行初始化或者赋值

派生类到基类转换的可访问性

基类到派生类的转换

static_cast
dynamic_cast

15.4 构造函数和复制控制
派生类型对象的构造 复制 赋值 和撤销
构造函数和赋值控制成员不能继承

该构造函数 隐式调用 基类的默认构造函数 初始化对象的基类部分

派生类构造函数中使用默认实参

5 只能初始化直接基类

尊重基类接口

15.4.3 复制控制和继承
一起进行 复制 赋值 撤销 
具有指针成员的类 一般需要定义自己的复制控制 来管理这些成员


定义派生类复制构造函数

派生类赋值操作符

构造函数和析构函数中的虚函数


15.5 继承情况下的类作用域
正是这种作用域的层次嵌套是我们能够直接访问基类的成员
1. 名字查找在编译时发生
对象 引用 指针
pair对象 

pair map
与基类成员同名的派生类成员将屏蔽对基类成员的直接访问
作用域与成员函数  只看函数名  基类成员会被屏蔽

重载函数

一个using声明只是指定一个名字，不能指定形参标


15.6  纯虚函数

纯虚函数  为后代类型提供了可以覆盖的接口 不能创建对象    =0 指定为纯虚函数

抽象基类 

15.7 容器与继承





===============================================
chap16
模板与泛型编程
泛型编程就是以独立于任何特定类型的方式编写代码，
泛型编程时，需要提供具体程序所操作的类型或值
标准库容器，迭代器 算法都是泛型编程的例子
每种容器都有单一的定义，可以定义许多不同种类的vector
区别在于所包含的元素类型

模板是泛型编程的基础
模板类和模板函数
使用模板时可以无需了解模板的定义

泛型编程 与面向对象编程一样 

泛型编程中  类和函数 多态的用于快鱼编译时不想管的类型
容器 迭代器 算法

C++中 模板是泛型编程的基础
模板是创建类或函数的蓝图或者公式

泛型函数 泛型类型

16.1 模板定义

重载函数 
定义函数模板
函数模板 独立于类型的函数

template<typename T>
int compare(const T &v1,const T& v2)
模板形参表  模板形参表 不能为空

模板形参表 函数形参表

类型形参和非类型形参
编译器推断模板实参绑定到模板形参  实例化了一个函数模板的实例

inline 函数模板
template<typename T> 
inline int compare(const T& v1,const T& v2)
{

}
定义类模板
自定义的queue类能够支持不同的类型的对象， 类模板

template<typename T>
class Queue{
    
    先定义类的接口
}
编译器使用实参来实例化这个类的特定类型的版本 实际上 编译器用用户提供的特定类型替代type 重新编写queue类

模板形参
类型形参   未知类型
非类型形参  未知值
模板形参作用域

重用函数形参
模板形参的名字也能在不同模板中重用





模板类型形参
类型说明符  
内置类型说明符
类类型说明符
函数模板形参表  

类 可以定义 数据成员 函数成员 类型成员

非类型模板形参

类型等价性与非类型形参

编写泛型程序， 编写模板时，代码不可能针对特定类型。

通过将形参设为const引用。就可以允许使用不允许复制的类型。



16.2 实例化
模板时一个蓝图，不是类或者函数

类模板形参是必须的

类模板不定义类型 只有特定的实例才定义了类型
Queue<int>
Queue<string>

模板实参推断 

类型形参的实参的受限转换

模板实参推断与函数指针
















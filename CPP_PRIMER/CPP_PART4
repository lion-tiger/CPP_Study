CPP_PART4
面向对象编程
模板与泛型编程

C++如何支持面向对象编程和泛型编程
chap15 继承和动态绑定  继承和动态绑定 与数据抽象是面向对象编程的基础
chap16 函数模板和类模板 模板 编写独立于具体类型的泛型类和泛型函数

对C++充分理解
标准库
类型和算法

chap15
面向对象编程
封装  数据抽象
继承
多态  动态绑定

动态绑定使编译器能够在运行时决定使用积累中定义的函数还是派生类中定义的函数
相关但略有不同的概念
面向对象编程  OOP  与这种应用匹配

15.1 面向对象编程 概述
多态性 
C++中 多态性仅用于通过继承而相关联的类型的引用或指针
继承 共享公共的东西 特化本质上不同的东西
函数特化
继承层次
在C++中 基类必须指出希望派生类重定义哪些函数 virtual
定义为virtual   基类希望派生类继承的函数不能定义为虚函数

动态绑定
    使用多态，编写程序使用继承层次中的任一类型的对象，无须关心对象的具体类型
    
    C++中 通过基类的引用 指针 调用虚函数时 发生动态绑定，
    
    
15.2
定义基类和派生类
在继承层次中定义类还需要另外一些特性
基类也有定义其接口和实现的数据和函数成员
继承层次的根类一般需要定义虚析构函数

-基类成员函数
基类通常应将派生类重定义的

private的成员只能有基类的成员或者友元访问
protected成员可以被派生类对象访问 而不能被该类型的普通用户访问

派生类  类派生列表
多继承与单继承

如果想要继承基类的接口 public
派生类可以继承基类的成员 也可以定义自己的附加成员
派生类只定义与基类不同或者扩展的类行为

派生类与虚函数
派生类型必须对想要重新定义的每个继承成员进行生命
派生类中的函数可以使用基类的成员
用作基类的类必须是已定义的
派生类的声明

15.2.4
virtual与其他成员函数
C++中函数调用默认不使用动态绑定

只需要正确的设计和实现类。


非虚函数在编译时就确定调用的函数
覆盖虚函数机制

递归

5 虚函数与默认实参
继承和组合

15.2.6 友元关系与继承


15.2.7
继承与静态成员


15.3 转换与继承
理解基类类类型和派生类类型之间的转换 对于理解面向对象编程正在C++中如何工作的非常关键

派生类类型引用到基类类型引用的自动转换

class Parent{

};
class Child : public Parent{

};

Parent *p;
Child  c;
p=&c;
Parent &conference = c;
编译器不会自动将派生类对象转换为基类类型对象

-引用转换不同于转换对象
    派生类类型的对象传给希望接受基类引用的函数
    void function(Parent& p)
    
    fucntion(c);
    将对象传递给希望金额受引用的函数时，引用直接绑定到该对象   实参是该对象的引用 对象本身未复制
    void function(Parent p)
    function(c);   形参的类型是固定的  该派生类对象的基类部分被复制到形参
    
    
- 用派生类对象对基类对象进行初始化或复制

初始化调用构造函数  复制时调用复制操作符  存在派生类引用到基类引用的转换  复制控制成员可用于从派生类对象对基类对象进行初始化或者赋值

派生类到基类转换的可访问性

基类到派生类的转换

static_cast
dynamic_cast

15.4 构造函数和复制控制
派生类型对象的构造 复制 赋值 和撤销
构造函数和赋值控制成员不能继承

该构造函数 隐式调用 基类的默认构造函数 初始化对象的基类部分

派生类构造函数中使用默认实参

5 只能初始化直接基类

尊重基类接口

15.4.3 复制控制和继承
一起进行 复制 赋值 撤销 
具有指针成员的类 一般需要定义自己的复制控制 来管理这些成员


定义派生类复制构造函数

派生类赋值操作符

构造函数和析构函数中的虚函数


15.5 继承情况下的类作用域
正是这种作用域的层次嵌套是我们能够直接访问基类的成员
1. 名字查找在编译时发生






===============================================
chap16
模板与泛型编程
泛型编程就是以独立于任何特定类型的方式编写代码，
泛型编程时，需要提供具体程序所操作的类型或值
标准库容器，迭代器 算法都是泛型编程的例子
每种容器都有单一的定义，可以定义许多不同种类的vector
区别在于所包含的元素类型

模板是泛型编程的基础
模板类和模板函数
使用模板时可以无需了解模板的定义













chap 1 你好 C++并发世界  
hello 并发编程

1998 C++ 初始的标准 

程序语言和它支持的库 新的C++标准 C++11  使得C++应用更加容易并富有成效

支持多线程程序 第一次在语言中承认多线程应用的存在  不依赖平台相关扩展
可移植的多线程代码  多线程提高应用程序的性能

C++编程中对多线程并发的使用。 相关的c++语言特性和库相关的工具

更深入的了解库工具

并发和多线程
1.1 什么是并发

单个系统同时执行多个独立的活动  多任务操作系统 任务切换
多个处理器的高性能 服务器
  多核心处理器
  
多个处理器或者一个多核心处理器  硬件并发   任务切换 上下文切换  CPU状态和指令指针 指令和数据  内存加载到缓存中

任务切换使得 后台任务可以运行
文字处理器 编译器 编辑器 web浏览器   任务整齐的划分为同等大小块的理想状态

开发人员代表一个线程 办公室代表一个处理器
多个单线程的进程 VS 一个 多线程的进程

多进程并发  应用程序分为多个 独立的 单线程的进程 网页浏览 文字处理。
常规的进程间通信  信号 套接字 文件 管道 共享内存  复杂 速度慢
操作系统在进程间做了大量的保护 避免一个进程修改另一个进程的数据   Erlang

多线程并发  线程 轻量级进程 每个线程相互独立运行  进程中的线程 共享地址空间 
通一数据的内存地址在不同的进程中不尽相同

线程间数据共享  开销更低  考虑共享内存。
C++标准 没有为进程间通信提供原生支持   平台相关的API

1.2 为什么使用并发
关注点分离和性能
划分关注点
程序 更容易理解和测试。
使用并发来分隔不同的功能区域 
一个线程处理用户输入，一个线程处理画面播放  线程间的交互可以被限制为  清晰可辨的点
多核芯片的设计

线程间划分任务的技巧


对多组数据同时执行相同的操作 数据并行

什么时候不使用并发？ 收益抵不过成本 脑力成本 额外的复杂性 导致更多的错误

操作系统必须分配相关的内盒资源和堆栈空间  线程是有限的资源，消耗操作系统资源  可用的内存或地址空间
每个线程需要独立的堆栈空间  代码 静态数据 堆数据

线程池
处理大量链接高需求服务器
多线程 更难理解 更容易出错。


1.3 在C++中使用并发和多线程

C++11中才能不依赖平台相关的扩展编写多线程代码。
新版本C++ 线程库中 众多规则背后的原理  了解历史
C++98 顺序抽象机  内存模型没有被定义
C++98 没办法在缺少编译器扩展的情况下编写多线程应用程序
编译器供应商可以自由的箱语言添加扩展 针对多线程的C API  POSIX C  VS  windows API

一个正式的多线程感知内存模型

不满足于使用平台相关的C API

处理器 操作系统 编译器 应用程序
C++程序员期望 类库能提供 面向对象的多线程工具

 
boost ACE C++通用类库 封装了下层的平台相关API
MFC 应用程序框架


C++类库共有的 RAI 带锁的资源获取初始化

现有的C++编译器提供的多线程编程

存在缺少线程告知内存模型 从而导致问题的场合

新的C++11标准    全新的线程感知内存模型 扩展C++标准库
共享命名和结构

C++中对原子操作的直接支持

C++整体 包含低级工具的 C++类   线程库

高性能计算的开发者 注重效率

抽象惩罚  一个全面的原子操作库   下放到平台相关的汇编语言中
更佳的可移植性和可维护性

低级别的工具
高级别的抽象和工具 使得编写多线程代码更简单和不易出错

运用特定的平台相关的工具
在所有的平台上，都有额外的平台相关工具
native_handle()

1.4 开始入门
与C++11兼容的 编译器
一个多线程C++程序 和所有的C++程序一样， 变量 类 函数的组合
唯一真正的区别在于某些函数可以并发运行 确保共享数据的并发访问时安全的。
为了并发的运行函数，必须使用特定的函数以及对象来管理各个线程


用于管理线程的函数和类  在<thread>中声明
保护共享数据的函数和类在其他头文件中声明

每个线程都有一个初始函数 新县城的执行在这里开始。
对于应用程序来说，初始线程是main 对于其他线程 在std::thread 的构造函数中指定  t对象拥有新函数hello作为其初始函数

该程序启动了一个全新的线程 初始线程是main 新线程始于hello
join 让main 等待hello线程结束之后再执行

C++中，使用多线程本身并不复杂，复杂的是 如何设计代码以实现预期的行为

管理线程的类和函数！！


chap2  管理线程
为应用程序使用并发
如何启动线程 检查他们已经完成 监视他们
C++标准库让 线程管理任务    与给定线程相关联的 std::thread 对象
对于不直观的任务，标准库也提供了从基本构建快进行按需构建的可扩展性
后台运行线程  线程函数启动时想起传递额外的参数

2.1 基本的线程管理
每个c++程序都至少拥有一个线程 C++运行时启动的 该线程运行着main函数

启动线程

一个接受额外参数的函数对象

std::thread 类的定义
可调用类型一同工作


新的统一化初始化方法！！
=======================================
201180122
线程 通过 构造 std::thread对象 该对象指定了线程上要运行的任务
任务 就是一个函数 void task()
该任务是一个  接受额外参数的函数对象


一系列由某种消息机制指定的互相独立的操作。

C++线程库开始一个线程 == 构造一个std::thread 对象

g++ thread1.cpp -pthread -std=c++11

void do_somework();
std::thread t(do_somework);


可调用类型
  函数
  重载（）  带有函数调用操作符的类的实例
  lambda函数

给线程构造函数传递一个函数对象
临时的且未命名的变量

新的统一初始化语法

  可调用对象
===========================================
class background_task{
public:
    void operator()() const{
        do_something();
        do_something_else();
    }
};


std::thread my_thread(background_task());
std::thread my_thread((background_task()));
std::thread my_thread{background_task()};


C++11 新功能
std::thread my_thread( []{
    do_something();
    do_something_else();
 } );
 
显示等待完成 结合它
自行运行     分离它

对象销毁之前决定。    对象和线程 2回事

必须确保线程访问的数据是有效的。

线程函数自包含  将数据拷贝到该线程中，而不是数据共享  警告包含有指针或者引用的对象  线程在函数退出前完成？

结合线程确保 函数退出前，该线程执行完毕。


2.1.2 等待线程完成
.join()

条件变量 future  替代机制

调用join的行为也会清理所有与该线程相关联的存储器


2.1.3 异常环境下的等待
确保访问局部状态的线程 在函数退出前结束       局部变量的引用

标准的资源获取即初始化 RAII  提供一个类 在析构函数里调用join()

对于一个给定的执行线程  join只能调用一次

2.1.4 在后台运行线程
t.detach()  一旦分离 不能再结合



chap 1 你好 C++并发世界  
hello 并发编程

1998 C++ 初始的标准 

程序语言和它支持的库 新的C++标准 C++11  使得C++应用更加容易并富有成效

支持多线程程序 第一次在语言中承认多线程应用的存在  不依赖平台相关扩展
可移植的多线程代码  多线程提高应用程序的性能

C++编程中对多线程并发的使用。 相关的c++语言特性和库相关的工具

更深入的了解库工具

并发和多线程
1.1 什么是并发

单个系统同时执行多个独立的活动  多任务操作系统 任务切换
多个处理器的高性能 服务器
  多核心处理器
  
多个处理器或者一个多核心处理器  硬件并发   任务切换 上下文切换  CPU状态和指令指针 指令和数据  内存加载到缓存中

任务切换使得 后台任务可以运行
文字处理器 编译器 编辑器 web浏览器   任务整齐的划分为同等大小块的理想状态

开发人员代表一个线程 办公室代表一个处理器
多个单线程的进程 VS 一个 多线程的进程

多进程并发  应用程序分为多个 独立的 单线程的进程 网页浏览 文字处理。
常规的进程间通信  信号 套接字 文件 管道 共享内存  复杂 速度慢
操作系统在进程间做了大量的保护 避免一个进程修改另一个进程的数据   Erlang

多线程并发  线程 轻量级进程 每个线程相互独立运行  进程中的线程 共享地址空间 
通一数据的内存地址在不同的进程中不尽相同

线程间数据共享  开销更低  考虑共享内存。
C++标准 没有为进程间通信提供原生支持   平台相关的API

1.2 为什么使用并发
关注点分离和性能
划分关注点
程序 更容易理解和测试。
使用并发来分隔不同的功能区域 
一个线程处理用户输入，一个线程处理画面播放  线程间的交互可以被限制为  清晰可辨的点
多核芯片的设计

线程间划分任务的技巧


对多组数据同时执行相同的操作 数据并行

什么时候不使用并发？ 收益抵不过成本 脑力成本 额外的复杂性 导致更多的错误

操作系统必须分配相关的内盒资源和堆栈空间  线程是有限的资源，消耗操作系统资源  可用的内存或地址空间
每个线程需要独立的堆栈空间  代码 静态数据 堆数据

线程池
处理大量链接高需求服务器
多线程 更难理解 更容易出错。


1.3 在C++中使用并发和多线程

C++11中才能不依赖平台相关的扩展编写多线程代码。
新版本C++ 线程库中 众多规则背后的原理  了解历史
C++98 顺序抽象机  内存模型没有被定义
C++98 没办法在缺少编译器扩展的情况下编写多线程应用程序
编译器供应商可以自由的箱语言添加扩展 针对多线程的C API  POSIX C  VS  windows API

一个正式的多线程感知内存模型

不满足于使用平台相关的C API

处理器 操作系统 编译器 应用程序
C++程序员期望 类库能提供 面向对象的多线程工具

 
boost ACE C++通用类库 封装了下层的平台相关API
MFC 应用程序框架


C++类库共有的 RAI 带锁的资源获取初始化

现有的C++编译器提供的多线程编程

存在缺少线程告知内存模型 从而导致问题的场合

新的C++11标准    全新的线程感知内存模型 扩展C++标准库
共享命名和结构

C++中对原子操作的直接支持

C++整体 包含低级工具的 C++类   线程库

高性能计算的开发者 注重效率

抽象惩罚  一个全面的原子操作库   下放到平台相关的汇编语言中
更佳的可移植性和可维护性

低级别的工具
高级别的抽象和工具 使得编写多线程代码更简单和不易出错

运用特定的平台相关的工具
在所有的平台上，都有额外的平台相关工具
native_handle()

1.4 开始入门
与C++11兼容的 编译器
一个多线程C++程序 和所有的C++程序一样， 变量 类 函数的组合
唯一真正的区别在于某些函数可以并发运行 确保共享数据的并发访问时安全的。
为了并发的运行函数，必须使用特定的函数以及对象来管理各个线程


用于管理线程的函数和类  在<thread>中声明
保护共享数据的函数和类在其他头文件中声明

每个线程都有一个初始函数 新县城的执行在这里开始。
对于应用程序来说，初始线程是main 对于其他线程 在std::thread 的构造函数中指定  t对象拥有新函数hello作为其初始函数

该程序启动了一个全新的线程 初始线程是main 新线程始于hello
join 让main 等待hello线程结束之后再执行

C++中，使用多线程本身并不复杂，复杂的是 如何设计代码以实现预期的行为

管理线程的类和函数！！


chap2  管理线程
为应用程序使用并发
如何启动线程 检查他们已经完成 监视他们
C++标准库让 线程管理任务    与给定线程相关联的 std::thread 对象
对于不直观的任务，标准库也提供了从基本构建快进行按需构建的可扩展性
后台运行线程  线程函数启动时想起传递额外的参数

2.1 基本的线程管理
每个c++程序都至少拥有一个线程 C++运行时启动的 该线程运行着main函数

启动线程

一个接受额外参数的函数对象

std::thread 类的定义
可调用类型一同工作


新的统一化初始化方法！！
=======================================
201180122
线程 通过 构造 std::thread对象 该对象指定了线程上要运行的任务
任务 就是一个函数 void task()
该任务是一个  接受额外参数的函数对象


一系列由某种消息机制指定的互相独立的操作。

C++线程库开始一个线程 == 构造一个std::thread 对象

g++ thread1.cpp -pthread -std=c++11

void do_somework();
std::thread t(do_somework);


可调用类型
  函数
  重载（）  带有函数调用操作符的类的实例
  lambda函数

给线程构造函数传递一个函数对象
临时的且未命名的变量

新的统一初始化语法

  可调用对象
===========================================
class background_task{
public:
    void operator()() const{
        do_something();
        do_something_else();
    }
};


std::thread my_thread(background_task());
std::thread my_thread((background_task()));
std::thread my_thread{background_task()};


C++11 新功能
std::thread my_thread( []{
    do_something();
    do_something_else();
 } );
 
显示等待完成 结合它
自行运行     分离它

对象销毁之前决定。    对象和线程 2回事

必须确保线程访问的数据是有效的。

线程函数自包含  将数据拷贝到该线程中，而不是数据共享  警告包含有指针或者引用的对象  线程在函数退出前完成？

结合线程确保 函数退出前，该线程执行完毕。


2.1.2 等待线程完成
.join()

条件变量 future  替代机制

调用join的行为也会清理所有与该线程相关联的存储器


2.1.3 异常环境下的等待
确保访问局部状态的线程 在函数退出前结束       局部变量的引用

标准的资源获取即初始化 RAII  提供一个类 在析构函数里调用join()

对于一个给定的执行线程  join只能调用一次

2.1.4 在后台运行线程
t.detach()  一旦分离 不能再结合

分离的线程 在后台运行  所有权和控制权 转交给C++运行时库 确保线程相关联的资源在线程退出后被正确的回收。


unix守护进程  守护线程   无需显示的用户界面 运行在后台 执行后台任务 监控文件系统 清理缓存 优化数据结构

执行线程 关联  std::thread对象
字处理器的应用程序
多个相互独立的顶层窗口，与正在编辑的文档一一对应

多个窗口 在同一个应用程序实例中

每个线程运行相同的代码   数据不一样。 拥有与被编辑文档相关的数据 以及对应的窗口属性  运行分离的线程



2.2 传递参数给线程函数
===================================
20180123
传递参数给可调用对象或者函数 将额外的参数传递给std::thread对象
参数以默认的方式复制到内部存储空间

对象被复制  你只需要对象的引用
传入data的引用 而非 data副本的引用



class X{}
public:
    void do_work();
};
X my_x;
std::thread t(&X::do_work,&my_x);




2.3 转移线程的所有权
创建一个后台运行的线程 向调用函数回传新线程的所有权
C++标准库 许多拥有资源的类型
std::ifstream
std::unique_ptr
std::thread
可移动的 可复制的

一个特定执行线程的所有权 在thread对象之间转移
从临时对象中进行移动是自动和隐式的
std::thread支持移动意味着所有权可以很容易的从一个函数中被转移出

以值的形式接收std::thread的实例作为其中一个参数

确保退出一个作用域之前线程都已经完成  scoped_thread


std::thread对移动的支持 同样考虑了std::thread对象的容器
如果容器是移动感知的

将std::thread对象放到std::vector中是线程迈向自动管理的第一步


2.4 在运行时选择线程数量
std::thread::hardware_currency()

线程间分隔任务

从线程中返回结果的替代方法 future


2.5 标识线程
std::thread::id 复制 比较
关系型容器中被用作主键 或者被排序
std::hash<std::thread::id>

  线程局部存储
关系型容器的主键

2.6 小结



========================================================================
========================================================================
第三章 在线程间共享数据
线程 并行   简单直接的共享数据

启动和管理线程 chap2
共享数据的相关问题  chap3
共享数据   有人借走了 东西  有些东西被别人改变了。

设置规则 哪个线程 访问数据哪一位 是么时间 更改notify

单个进程中的多个线程共享数据 只能算是特点

C++线程间安全的共享数据 避免可能出现的潜在问题

3.1 线程间共享数据的问题
修改数据

不变量 invariants
修改线程间共享数据 最简单的潜在问题 就是破坏不变量

程序崩溃
并发代码中错误 最常见的诱因之一  竞争条件
得到哪个作为 取决于购买的先后顺序

竞争条件导致损坏不变量 以双向链表为例

race condition
data race

修改两个或者多个不同的数据块
竞争条件很难找到或者复现 因为机遇的窗口很小   竞争条件一般是时间敏感的，调试工具会影响程序的时间，即便只是轻微的

多线程程序 == 并发

3.1.2 避免有问题的竞争条件

保护机制封装数据结构

内存模型 第5章
无锁编程 第7章

软件事务内存 C++没有对STM的直接支持

C++标准提供的保护共享数据的最基本机制是互斥元 mutex

3.2 用互斥元保护共享数据

链表 的数据结构 免于竞争条件   不变量破坏
互斥元 mutex 同步原语

线程库 会确保 一旦一个线程 已经锁定某个互斥元

锁定与该数据相关的互斥元

互斥元是C++中最常见的数据保护机制 
精心组织代码保护正确的数据 避免接口中固有的竞争条件 死锁 保护过多 过少。


std::mutex 
标准C++库提供了std::lock_guard类模板 实现了互斥元RAII惯用语法


构造函数上锁 析构函数解锁 从而保证被锁定的互斥元始终被正确解锁

std::mutex  保护一个可被多个线程访问的列表

在大多数情况下，不使用全局变量，在类中将互斥元和受保护的数据组织在一起。--这是一个标准的面向对象应用程序设计规则。
将他们放在一个类中，清楚的表明他们是相关的

迷路的指针或者引用容易引发保护不全的问题

同一个层面上， 没有成员函数通过其返回值或者输出参数 返回受保护数据的指针或者引用给调用者。 数据就安全了。

更深入一些 没有那么直观
1 检查成员函数没有向其调用者传出指针和引用
2 没有向其调用的不在你的掌控之下的函数纯如这种指针和引用  这些函数可能将指针和引用存储在某个地方， 脱离互斥元的保护而被使用
    特别是函数是通过函数参数或其他方式在运行时提供的   注册机制
    
    3.2.2
    清单3-2  不懂？？
    
    3.2.3 发现接口中固有的竞争条件
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    std::stack
    
    
    
    
    

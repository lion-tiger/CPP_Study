数字和静态   数字很重要

primitive主数据类型
某种特定的格式来打印日期
字符串转换成数字

Java API 有很多与数字有关的方法

很多方法是静态的   静态的变量和方法   静态final变量这种java常数


在java中 没有东西是全局的

Math方法 最接近全局的方法
一种方法 不依赖实例变量的值  方法会对参数执行操作，操作不受实例变量状态的影响 唯一能够改变round()行为的只有所传入的参数

在堆上建立math对象 浪费资源 不需要创建math的实例，无法创建

math所有方法都不需要实例变量，方法都是静态的，无需math实例，你用的是math类本身
这些方法无需实例变量，不需要特定对象来判别行为

math的构造函数被标记为私有的 不能创建math对象
抽象类也是不能创建对象



-- 非静态方法和静态方法的区别
java是面向对象的 特殊的情况下  使用方法，而不需要类的实例

static这个关键字可以标记出不需要实例的方法   一个静态的方法， 一种不依靠实例变量也就不需要对象的行为

实例变量的值会影响play方法的行为

没有实例变量
直接使用类的名字 没有对象 绝对没有对象  以类的名称调用静态方法

Math.min(32,43);
以引用变量的名称调用非静态方法

私有构造函数




带有静态方法的类 通常不打算初始化
abstract 标记一个类 不让其创建实例  抽象的类是不能被初始化的！！

也可以用私有构造函数来限制非抽象类被初始化
标记为private的方法只能被同一类程序所调用

math通过私有构造函数来防止其被初始化  无法创建math实例，编译器知道不能存取这些私有的构造函数

这不标明 有 静态方法的类不能 被初始化

main方法 启动或者测试其他的类 从main中创建类的实例并调用实例上 的方法

可以任意地在类中组合 静态的和非静态的方法 任何非静态的方法代表必须以某种实例来操作

取得新对象的方法   new 序列化  java Reflection API

========================
静态方法不能调用非静态变量
静态方法是无关 特定类的实例 情况下执行的，
静态方法不知道堆上是哪个实例   无法从静态上下文中引用非静态变量

========================
非静态的方法，  以实例变量的状态来影响该方法的行为

静态方法无法看到实例变量的状态

可以以引用变量 代替 类名  调用静态方法的 程序代码


Duck d = new Duck();
String[] s = {};
d.main(s);


静态变量 的值对所有的类 对象实例 来说都相同

duckCount是个实例变量  需要的是只会有一份拷贝的变量 且所有实例都会用到该拷贝    被同类的所有实例共享的变量

此静态变量只会在列第一次载入的时候被初始化    Duck不会维护一份自己的DuckCount拷贝


静态变量是共享的
同一类所有的实例共享一份静态变量

只能创建一个实例的类  单例模式

私有的构造函数代表这个类不能被本身以外的程序给实例化

静态变量的起始动作   静态变量是在类被加载的时候初始化的

类被加载时因为java虚拟机认为它该被加载了


通常，java虚拟机加载某个类    第一次有人阐释创建该类的新实例，或者使用该类的静态变量或方法



静态变量会在该类的任何对象创建之前就完成初始化
静态变量会在该类的静态方法执行之前就初始化

静态变量通过类的名称来存取


静态的final变量是常数
一个别标记为final的变量表明 他一旦被初始化就不会再改动

public static final double PI = 3.1415926538;

静态初始化程序
class Foo{
    final static int x;
    static{
        x=42;
    }
}

静态final变量的初始化：1 声明的时候 2 在静态初始化程序中初始化

final不只用在静态变量上  实例变量 局部变量 方法参数
也可以用final防止方法被覆盖 或者创建子类

final 变量 方法 类


在java中的 敞亮是把变量同事标记为static何final
可以将构造函数标记为private防止被初始化
静态的方法应该用类名来调用，而不是用 对象引用变量



















